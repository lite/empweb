-module(empdb_dao).


-include_lib("epgsql/include/pgsql.hrl").

-compile(export_all).

-define(SVAR, "$").

%%%
%%% Спецификации
%%%

-export([behaviour_info/1]).

behaviour_info(callbacks) ->
    [
        {table,     0},
            %% ::= table(name)
        {table,     1},
            %% {fields, insert, required}
            %% {fields, insert}
            %% {fields, select}
            %% {fields, update}
            %% {fields, all}
            %% name
        {create,    2},
        {update,    2},
        {get,       2},
        {get,       3},
        {is_owner,  2}
    ];
behaviour_info(_Other) ->
    undefined.



%%% -----------------------------------------------------------------------

fields(all) ->
    fields([], all);

fields(Fields) ->
    fields(Fields, []).

fields(Fields, all) ->
    fields(Fields, <<"*">>);

fields(Fields, Default) ->
    fields(Fields, Default, []).

fields(all, Default, Additions) ->
    fields_([], [], Default, Additions);

fields(Fields, Default, Additions) ->
    fields_([], Fields, Default, Additions).
    
%%% -----------------------------------------------------------------------

table_fields(Table, Fields) ->
    table_fields(Table, Fields, []).

table_fields(Table, Fields, Default) ->
    table_fields(Table, Fields, Default, []).

table_fields(Table, Fields, Default, Additions) ->
    fields_([empdb_convert:to_binary(Table), <<".">>], Fields, Default, Additions).

%%% -----------------------------------------------------------------------

fields_(_, [], [], _additions) ->
   <<>>;

fields_(Table, [], [D|Rest] = Default, Additions) when erlang:is_atom(D) ->
    fields_(Table, Default, [], Additions);

fields_(_, [], Default, _additions) ->
   Default;

fields_(Table, Fields, _default, Additions) ->
    [[_|First]|Res] = lists:map(fun(Field)->
        [<<",">> ,[empdb_convert:to_binary(Table), empdb_convert:to_binary(Field)]]
    end,lists:append(Fields, Additions)),
    [<<" ">>, [First|Res], <<" ">>].

%%% -----------------------------------------------------------------------


fieldvars(Fields) ->
    fieldvars(Fields, []).

fieldvars(Fields, Default) ->
    fieldvars(Fields, Default, []).

fieldvars([], Default, _additions) ->
    Default;
fieldvars(Fields, _default, Additions) ->
    [[_|First]|Res] = lists:map(fun(Field)->
        [<<",">> , [<<"$">>, empdb_convert:to_binary(Field)]]
    end,lists:append(Fields, Additions)),
    [<<" ">>, [First|Res], <<" ">>].

%%% -----------------------------------------------------------------------

fields_fieldvars(Fields)->
    fields_fieldvars(Fields, []).

fields_fieldvars(Fields, Default)->
    fields_fieldvars(Fields, Default, []).

fields_fieldvars([], Default, _additions) ->
    Default;
fields_fieldvars(Fields, _default, Additions) ->
    [[_|First]|Res] = lists:map(fun(Field)->
        [<<",">> , [empdb_convert:to_binary(Field), <<"=$">>, empdb_convert:to_binary(Field)]]
    end,Fields),
    [<<" ">>, [First|Res], <<" ">>].

%%% -----------------------------------------------------------------------
%%% -----------------------------------------------------------------------
%%% -----------------------------------------------------------------------

table_options({table, fields, all},      Current) ->
    ['and', 'or' | proplists:get_value({table, fields, all}, Current)];

table_options(Oname,      Current) ->
    proplists:get_value(Oname, Current).

sql_and(List)->
    {Tlist, String} = sql_list(List),
    {   Tlist,
        [   <<"(">>,
                string:join(String,[<<" and ">>]),
            <<")">>
        ]
    }.

sql_or(List)->
    {Tlist, String} = sql_list(List),
    {   Tlist,
        [   <<"(">>,
                string:join(String,[<<" or ">>]),
            <<")">>
        ]
    }.

sql_list(List) ->
    io:format("List = ~p~n", [List]),
    {Tlist, String} = lists:unzip([sql_cond({Ff, Val})||{Ff, Val} <- List]),
    io:format("String = ~p~n", [String]),
    {lists:flatten(Tlist), String}.

sql_cond({'and', List}) ->
    sql_and(List);

sql_cond({'or', List}) ->
    sql_or(List);


sql_cond({Ff, {'and', Conds}})->
    X =
        {   'and',
            lists:map(
                fun(Cond)->
                    {Ff, Cond}
                end,
                Conds
            )
        },
    sql_cond(X);

sql_cond({Ff, {'or', Conds}})->
    io:format("Conds = ~p~n", [Conds]),
    X =
        {   'or',
            lists:map(
                fun(Cond)->
                    {Ff, Cond}
                end,
                Conds
            )
        },
    sql_cond(X);

sql_cond({Ff, {between, {Left, Right}}}) ->
    Bnleft   = empdb_convert:to_binary([
        <<"__">>,
        empdb_convert:to_binary(Ff),
        <<"__left__">>
    ]),
    Bnright  = empdb_convert:to_binary([
        <<"__">>,
        empdb_convert:to_binary(Ff),
        <<"__right__">>
    ]),
    Nleft    = empdb_convert:to_atom(Bnleft),
    Nright   = empdb_convert:to_atom(Bnright),
    {   [{Nleft,Left},{Nright, Right}],
        [   empdb_convert:to_binary(Ff),
            <<" between ">>, ["$",Bnleft], <<" and ">>, ["$",Bnright]
        ]
    };

sql_cond({Ff, {iregex, Regex}})
    when erlang:is_binary(Regex) orelse erlang:is_list(Regex) ->
    {   [],
        [   empdb_convert:to_binary(Ff),
            <<" ~* '">>,
            empdb_convert:to_binary(Regex),
            <<"'">>
        ]
    };

sql_cond({Ff, {regex, Regex}})
    when erlang:is_binary(Regex) orelse erlang:is_list(Regex) ->
    {   [],
        [   empdb_convert:to_binary(Ff),
            <<" ~ '">>,
            empdb_convert:to_binary(Regex),
            <<"'">>
        ]
    };

sql_cond({Ff, {startswith, Startswith}}) ->
    sql_cond({Ff, {like, [<<"%">>, Startswith]}});

sql_cond({Ff, {endswith, Endswith}}) ->
    sql_cond({Ff, {like, [Endswith, <<"%">>]}});

sql_cond({Ff, {contains, Contains}}) ->
    sql_cond({Ff, {like, [<<"%">>, Contains, <<"%">>]}});

sql_cond({Ff, {like, Like}})
    when erlang:is_binary(Like) orelse erlang:is_list(Like) ->
    {   [],
        [   empdb_convert:to_binary(Ff),
            <<" like '">>,
            empdb_convert:to_binary(Like),
            <<"'">>
        ]
    };

sql_cond({Ff, {istartswith, Startswith}}) ->
    sql_cond({Ff, {ilike, [<<"%">>, Startswith]}});

sql_cond({Ff, {iendswith, Endswith}}) ->
    sql_cond({Ff, {ilike, [Endswith, <<"%">>]}});

sql_cond({Ff, {icontains, Contains}}) ->
    sql_cond({Ff, {ilike, [<<"%">>, Contains, <<"%">>]}});

sql_cond({Ff, {ilike, Like}})
    when erlang:is_binary(Like) orelse erlang:is_list(Like) ->
    {   [],
        [   empdb_convert:to_binary(Ff),
            <<" ilike '">>,
            empdb_convert:to_binary(Like),
            <<"'">>
        ]
    };

sql_cond({Ff, {lt, Val}}) ->
    {   [{Ff, Val}],
        [   empdb_convert:to_binary(Ff),
            <<" < $">>,
            empdb_convert:to_binary(Ff)
        ]
    };

sql_cond({Ff, {lte, Val}}) ->
    {[{Ff, Val}], [empdb_convert:to_binary(Ff),<<" <= $">>,empdb_convert:to_binary(Ff)]};

sql_cond({Ff, {gt, Val}}) ->
    {[{Ff, Val}], [empdb_convert:to_binary(Ff),<<" > $">>,empdb_convert:to_binary(Ff)]};

sql_cond({Ff, {gte, Val}}) ->
    {[{Ff, Val}], [empdb_convert:to_binary(Ff),<<" >= $">>,empdb_convert:to_binary(Ff)]};

sql_cond({Ff, {in, []}}) ->
    {[], []};

sql_cond({Ff, {in, List}}) when erlang:is_list(List) ->
    {[], [
        empdb_convert:to_binary(Ff),
        <<" in (">>,
        string:join(
            [   [empdb_convert:to_binary(Li)]
                || Li <- List
            ],
            <<",">>
        ),
        <<")">>
    ]};

sql_cond({Ff, Val} = Tuple) ->
    {[{Ff, Val}], [
        empdb_convert:to_binary(Ff),
        <<" = $">>,
        empdb_convert:to_binary(Ff)
    ]}.

sql_where(<<>>)->
    {[], []};

sql_where([])->
    {[], []};

sql_where(Current_all_fields)->
    {PField, Pstring} = sql_and(Current_all_fields),
    {PField, [<<" where ">>, Pstring]}.

sql_returning([]) ->
    [];

sql_returning(<<>>) ->
    [];

sql_returning([{Fitem, _}|Rfilter] = Filter) ->
    [   <<"returning ">>,
        empdb_convert:to_binary(Fitem),
        lists:map(fun({Item, _}) ->
            [<<" ,">>, empdb_convert:to_binary(Item)]
        end,Rfilter)
    ];

sql_returning([Fitem|Rfilter] = Filter) ->
    [   <<"returning ">>,
        empdb_convert:to_binary(Fitem),
        lists:map(fun(Item) ->
            [<<" ,">>, empdb_convert:to_binary(Item)]
        end,Rfilter)
    ];

sql_returning(Filter) ->
    [   <<"returning ">>,
        empdb_convert:to_binary(Filter)
    ].

%%% -----------------------------------------------------------------------
%%% -----------------------------------------------------------------------
%%% -----------------------------------------------------------------------


%%
%% @doc Структура описания запроса. 
%%      Пока не используется.
%%
-record(queryobj, {
    %% Для select \ insert \ update \ delete
        filter = [] :: proplists:proplist(),
    %% Для select
        fields = [] :: list(),
    %% Для insert \ update
        values = [] :: proplists:proplist(),
    %% Для insert \ update
        return = [id] :: list(),
    %% Для select \ insert \ update \ delete
        limit  = undefined :: undefined | integer(),
    %% Для select \ insert \ update \ delete
        offset = undefined :: undefined | integer()
}).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% @doc Выполняет select. Позволяет получить одну сущность 
%%      единственной таблицы.
%%
%%      Операторы:
%%              and 
%%              or
%%
%%          Операторы надо строками, префикс i в начале означает,
%%          что регистр учитываться не будет:
%%
%%                  like,           ilike
%%                      Сопосталение в терминах sql.
%%                  regex,           iregex
%%                      Регулярные выражения.
%%                  contains,       icontains
%%                      Проверка на вхождение.
%%                  startswith,     istartswith
%%                      Проверка префикса.
%%                  endswith,       iendswith
%%                      Проверка суффикса.
%%                  between
%%                      Проверка вхождения.
%%
%%      Примеры:
%%          ----------------------------------------------------------------
%%          empdb_dao_some:get(Connection,
%%              [ 
%%                  {'or', 
%%                      [
%%                          {name, {contains, <<"lennon">>}},
%%                          {name, {startswith, <<"jo">>}}
%%                      ]
%%                  }
%%              ]
%%          ).
%%          ----------------------------------------------------------------
%%          empdb_dao_some:get(Connection,
%%              [
%%                  {'fname',
%%                      {'or', 
%%                          [
%%                              {contains, <<"lennon">>}, 
%%                              {startswith, <<"jo">>}
%%                          ]
%%                      }
%%                  }
%%              ]
%%          ).
%%          ----------------------------------------------------------------
%%          empdb_dao_some:get(Connection, [{id, {'between', {3, 33}}}]).
%%          ----------------------------------------------------------------
%%
%%      Зарезервированные слова: limit, offset
%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

get(Current, Con, {Key, Value}, Fields)->
    get(Current, Con, [{Key, Value}], Fields);

get(Current, Con, Filter, Fields)
        when erlang:is_list(Filter), erlang:is_list(Current) ->
    Common_all_fields =
        table_options({table, fields, all}, Current),
    Common_select_fields =
        table_options({table, fields, select}, Current),
    Current_select_fields =
        lists:filter(
            fun(F)-> lists:member(F, Common_select_fields) end,
            Fields
        ),
    Current_all_fields =
        lists:filter(
            fun({F, _})->
                lists:member(F, Common_all_fields)
            end,
            Filter
        ),
    case Current_all_fields of
        [] ->
            {error, {wrong_field, proplists:get_keys(Filter)}};
        _ ->
            Binary_table_name =
                empdb_convert:to_binary(table_options({table, name},  Current)),
            Binary_select_fields =
                fields(
                    Current_select_fields,
                    Common_select_fields
                ),
            {Pfields, Where_string} =
                sql_where(Current_all_fields),
            Query = [
                <<"select ">>,  Binary_select_fields,
                <<" from ">>,   Binary_table_name,
                Where_string,
                [   %% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    %% TODO: опасные моменты надобно переделать на record
                    %% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    case proplists:get_value(limit, Filter) of
                        undefined ->
                            [];
                        Limit ->
                            [<<" limit ">>, empdb_convert:to_list(Limit), <<" ">> ]
                    end,
                    case proplists:get_value(offset, Filter) of
                        undefined ->
                            [];
                        Offset ->
                            [<<" offset ">>, empdb_convert:to_list(Offset), <<" ">> ]
                    end
                ]
            ],
            empdb_dao:pgret(empdb_dao:equery(Con, Query, Pfields))
    end;

get(Current, Con, Filter, Fields) when erlang:is_list(Filter) ->
    Current = [
        {{table, name},             Current:table(name)},
        {{table, fields, all},      Current:table({fields, all})},
        {{table, fields, select},   Current:table({fields, select})}
    ],
    get(Current, Con, Filter, Fields).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% @doc Выполняет select join для таблиц описанных через
%%      {Parent, Parent_field}, {Current, Current_field}
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

get({Parent, Parent_field}, {Current, Current_field}, Con, Filter, Fields)
    when    erlang:is_list(Filter),
            erlang:is_list(Current),
            erlang:is_list(Parent)  ->
    Common_all_fields = lists:append(
        table_options({table, fields, all},      Parent),
        table_options({table, fields, all},      Current),
    ),
    Common_select_fields = lists:append(
        table_options({table, fields, select},   Parent),
        table_options({table, fields, select},   Current)
    ),
    Current_select_fields =
        lists:filter(
            fun(F)->
                lists:member(F, Common_select_fields)
            end,
            Fields
        ),
    Current_all_fields =
        lists:filter(
            fun({F, _})->
                lists:member(F, Common_all_fields)
            end,
            Filter
        ),
    case Current_all_fields of
        [] ->
            {error, {wrong_field, proplists:get_keys(Filter)}};
        _ ->
            Binary_parent_name =
                empdb_convert:to_binary(table_options({table, name},Parent)),
            Binary_table_name =
                empdb_convert:to_binary(table_options({table, name},Current)),
            Binary_select_fields =
                fields(
                    Current_select_fields,
                    Common_select_fields
                ),
            Binary_current_field =
                empdb_convert:to_binary(Current_field),
            Binary_parent_field =
                empdb_convert:to_binary(Parent_field),
            {Pfields, Where_string} =
                sql_where(Current_all_fields),
            Query = [
                %% поля обоих таблиц в перемешку
                <<" select ">>, Binary_select_fields,
                %% родительская таблиа
                <<" from ">>,   Binary_parent_name,
                %% дочерняя таблиа
                <<" join ">>,   Binary_table_name,
                %% сцепление таблиц
                <<" on ">>, [
                    Binary_table_name,  <<".">>,    Binary_current_field,
                    <<" =  ">>,
                    Binary_parent_name, <<".">>,    Binary_parent_field
                ],
                Where_string,
                [   %% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    %% TODO: опасные моменты надобно переделать на record
                    %% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    case proplists:get_value('limit', Filter) of
                        undefined ->
                            [];
                        Limit ->
                            [<<" limit ">>, empdb_convert:to_list(Limit), <<" ">> ]
                    end,
                    case proplists:get_value('offset', Filter) of
                        undefined ->
                            [];
                        Offset ->
                            [<<" offset ">>, empdb_convert:to_list(Offset), <<" ">> ]
                    end
                ]
            ],
            empdb_dao:pgret(empdb_dao:equery(Con, Query, Pfields))
    end;

get({Parent, Parent_field}, {Current, Current_field}, Con, Filter, Fields)->
    Oparent = [
        {{table, name},             Parent:table(name)},
        {{table, fields, all},      Parent:table({fields, all})},
        {{table, fields, select},   Parent:table({fields, select})}
    ],
    Omodule = [
        {{table, name},             Current:table(name)},
        {{table, fields, all},      Current:table({fields, all})},
        {{table, fields, select},   Current:table({fields, select})}
    ],
    get({Oparent, Parent_field}, {Omodule, Current_field}, Con, Filter, Fields);


get(Par, Cur, Con, {Key, Value}, Fields)->
    get(Par, Cur, Con, [{Key, Value}], Fields).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Добавление нового
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

create({Parent, Parent_field}, {Current, Current_field}, Con, Proplist, Returning1, Returning2)->
    case create(Parent, Con, Proplist, Returning1) of
        {ok, Pid} ->
            create(Current, Con, [{Current_field, Pid}|Proplist], Returning2);
        {Eclass, Error} ->
            {Eclass, Error}
    end.

create({Parent, Parent_field}, {Current, Current_field}, Con, Proplist, Returning2)->
    create({Parent, Parent_field}, {Current, Current_field}, Con, Proplist, id, Returning2).

create(Current, Con, Proplist)->
    create(Current, Con, Proplist, id).

create({Parent, Parent_field}, {Current, Current_field}, Con, Proplist) ->
    create({Parent, Parent_field}, {Current, Current_field}, Con, Proplist, Parent_field, Current_field);

create(Current, Con, Proplist, Returning) when erlang:is_list(Current)->
    Kvalues = lists:filter(
        fun({F, _})->
            lists:member(
                F,
                proplists:get_value(
                    {table, fields, insert},
                    Current
                )
            )
        end,
        Proplist
    ),
    Fields = proplists:get_keys(Kvalues),
    Required = table_options({table, fields, insert, required}, Current),
    case lists:foldl( fun(F, R)-> R and lists:member(F, Fields) end, true, Required ) of
        true ->
            Binary_table_name    = empdb_convert:to_binary(
                table_options({table, name}, Current)
            ),
            Binary_select_fields     = fields(Fields),
            Dfvs    = empdb_dao:fieldvars(Fields),
            empdb_dao:pgret(empdb_dao:equery(Con,[
                <<"insert into ">>,
                    Binary_table_name,
                <<"(">>,
                    Binary_select_fields,
                <<")values(">>,
                    Dfvs,
                <<") ">>,
                    sql_returning(Returning)
            ], Kvalues));
        _ ->
            {error, {required, Required}}
    end;

create(Current, Con, Proplist, Returning)->
    Current = [
        {{table, name},             Current:table(name)},
        {{table, fields, insert},   Current:table({fields, insert})},
        {{table, fields, insert, required},   Current:table({fields, insert, required})}
    ],
    create(Current, Con, Proplist, Returning).



%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Обновление старого
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


update({Parent, Parent_field}, {Current, Current_field}, Con, Proplist, Filter1, Filter2)->
    case update(Parent, Con, Proplist,Filter1) of
        {ok, Pid} ->
            X = update(Current, Con, [{Filter2, Pid}|Proplist], Filter2),
            io:format("X  = ~p ~n", [X]),
            X;
        {Eclass, Error} ->
            {Eclass, Error}
    end.

update({Parent, Parent_field}, {Current, Current_field}, Con, Proplist, Filter2)->
    update({Parent, Parent_field}, {Current, Current_field}, Con, Proplist, id, Filter2).

update(Current, Con, Proplist)->
    update(Current, Con, Proplist, id).

update({Parent, Parent_field}, {Current, Current_field}, Con, Proplist) ->
    update({Parent, Parent_field}, {Current, Current_field}, Con, Proplist, Parent_field, Current_field);

% 
% update(Current, Con, Proplist, []) ->
%     update(Current, Con, Proplist, id);

update(Current, Con, Kvset, [{K, V}]=Kvwhere) when erlang:is_list(Current), erlang:is_list(Kvwhere) ->
    Common_all_fields = table_options({table, fields, all},     Current),
    Ufields = table_options({table, fields, update},  Current),
    Fkvset   = lists:filter(fun({F, _})-> lists:member(F, Ufields) end, Kvset),
    Fkvwhere = lists:filter(fun({F, _})-> lists:member(F, Common_all_fields) end, Kvwhere),

    case {Fkvset, Fkvwhere} of
%         {_, []} ->
%             create(Current, Con, Kvset, Kvwhere);
%         {[], _} ->
%             {ok, {Fkvwhere}};
        {Fkvset, Fkvwhere} ->
            Tname   = table_options({table, name}, Current),
            Btname  = empdb_convert:to_binary(Tname),
            Dffvset = fields_fieldvars(proplists:get_keys(Fkvset)),
            case empdb_dao:pgret(empdb_dao:equery(Con,[
                <<" update  ">>,
                    Btname,
                <<" set ">>,
                    Dffvset,
                sql_where(Fkvwhere)
            ], lists:append(Fkvset, Fkvwhere))) of
                {ok, Count} ->
                    {ok, [{[{count, Count}|Fkvwhere]}]};
                {error, Error} ->
                    {error, Error}
            end
    end;

update(Current, Con, Kvset, Keyswhere) when erlang:is_list(Current), erlang:is_list(Keyswhere) ->
    Common_all_fields     = table_options({table, fields, all},     Current),
    Ufields     = table_options({table, fields, update},  Current),
    Fkvset      = lists:filter(fun({F, _})-> lists:member(F, Ufields) end, Kvset),
    Fkeyswhere  = lists:filter(fun(F)-> lists:member(F, Common_all_fields) end, Keyswhere),
    Fkvwhere    = lists:filter(fun({F, _})-> lists:member(F, Fkeyswhere) end, Kvset),
    case {Fkvset, Fkvwhere} of
%         {_, []} ->
%             create(Current, Con, Kvset, Keyswhere);
%         {[], _} ->
%             {ok, {Fkvwhere}};
        {Fkvset, Fkvwhere} ->
            Tname   = table_options({table, name}, Current),
            Btname  = empdb_convert:to_binary(Tname),
            Dffvset = fields_fieldvars(proplists:get_keys(Fkvset)),
            case empdb_dao:pgret(empdb_dao:equery(Con,[
                <<" update  ">>,
                    Btname,
                <<" set ">>,
                    Dffvset,
                <<" ">>,
                    sql_where(Fkvwhere),
                <<" ">>
            ], lists:append(Fkvset, Fkvwhere))) of
                {ok, Count} ->
                    {ok, [{[{count, Count}|Fkvwhere]}]};
                {error, Error} ->
                    {error, Error}
            end
    end;

update(Current, Con, Proplist, Filter) when erlang:is_list(Current), erlang:is_atom(Filter) ->
    Kname = Filter,
    Fields = lists:filter(
        fun(F)->
            lists:member(F,
                table_options({table, fields, update}, Current)
            )
        end,
        proplists:get_keys(Proplist)
    ),
    case proplists:get_value(Kname, Proplist) of
        undefined ->
            create(Current, Con, Proplist, Filter);
        Kval ->
            case lists:filter(
                    fun({F, V})->lists:member(
                            F,
                            proplists:get_value(
                                {table, fields, update},
                                Current
                    )) end, Proplist
            ) of
                [] ->
                    {ok, Kval};
                Pls ->
                    Binary_table_name = empdb_convert:to_binary(table_options({table, name}, Current)),
                    Dffvs = fields_fieldvars(Fields),
                    case empdb_dao:pgret(empdb_dao:equery(Con,[
                        <<" update  ">>,
                        Binary_table_name,
                        <<" set ">>,
                        Dffvs,
                        <<" where ">>,
                        [   empdb_convert:to_binary(Filter),
                            <<" = $">>,
                            empdb_convert:to_binary(Kname)
                        ]
                    ],[{Kname, Kval}|Pls])) of
                        {ok, Count} ->
                            {ok, [{[
                                {Kname, Kval},
                                {count, Count}
                            ]}]};
                        {error, Error} ->
                            {error, Error}
                    end
            end
    end;

update(Current, Con, Proplist, Filter)->
    Current = [
        {{table, name},             Current:table(name)},
        {{table, fields, all},      Current:table({fields, all})},
        {{table, fields, insert},   Current:table({fields, insert})},
        {{table, fields, insert, required},   Current:table({fields, insert, required})},
        {{table, fields, update},   Current:table({fields, update})}
    ],
    update(Current, Con, Proplist, Filter).

%%% -----------------------------------------------------------------------
%%% -----------------------------------------------------------------------




pg2rs({ok, _, Vals}, Record_name) ->
    [list_to_tuple([Record_name | tuple_to_list(X)]) || X <- Vals];

pg2rs(Vals, Record_name) ->
    [list_to_tuple([Record_name | tuple_to_list(X)]) || X <- Vals].

strip_rs(Vals) when is_list(Vals)->
    strip_rs(Vals, []);

strip_rs(Val) when is_tuple(Val) ->
    [_|T]=tuple_to_list(Val),
    T.

strip_rs([Vh|Vt], Ret) ->
    [_|T]=tuple_to_list(Vh),
    strip_rs(Vt, [list_to_tuple(T)|Ret]);
strip_rs([], Ret) ->
    Ret.

collect_where_params(Params) ->
    collect_where_params([], [], Params).

collect_where_params(Where, Params, [{Val}|T]) when is_list(Val) ->
    collect_where_params([Val|Where], Params, T);
collect_where_params(Where, Params, [{Key, Val}|T]) ->
    collect_where_params(Where, Params, [{Key, "=", Val}|T]);
%    collect_where_params([lists:append([Key, " = $", empdb_convert:to_list(length(Params) + 1)])|Where], [Val | Params], T);
collect_where_params(Where, Params, [{Key, Action, Val}|T]) ->
    collect_where_params([lists:append([Key, " ", Action, " $", empdb_convert:to_list(length(Params) + 1)])|Where], [Val | Params], T);
collect_where_params(Where, Params, []) when length(Where) > 0->
    {" WHERe", [string:join(lists:reverse(Where), " and ")], lists:reverse(Params)};
collect_where_params(_, _, []) ->
    {";", []}.


to_type(null, _Type) ->
    null;


to_type(V,  timestamp) ->
    Bas = calendar:datetime_to_gregorian_seconds({{1970,1,1},{0,0,0}}),
    {X, {H, M, S}} = V,
    Ts = trunc(S),
    Cur = calendar:datetime_to_gregorian_seconds({X, {H, M, Ts}}),
    trunc((Cur - Bas + S - Ts) * 1000000);

to_type(V, int4) ->
    empdb_convert:to_integer(V);

to_type(V, numeric) ->
    empdb_convert:to_integer(V);

to_type(<<"f">>, bool) ->
    false;
to_type(<<"t">>, bool) ->
    true;

to_type(V, varchar) ->
    V;
to_type(V, text) ->
    V;
to_type(V, Type) ->
    io:format("Type= ~p~n", [Type]),
    V.


% name_columns([{column, Name, Type, _P3, _P4, _P5}|Ct], [V|Vt], Ret) ->
%     name_columns(Ct, Vt, [{binary_to_list(Name), to_type(V, Type)}|Ret]);
    
name_columns([{column, Name, Type, _P3, _P4, _P5}|Ct], [V|Vt], Ret) ->
    name_columns(
        Ct,
        Vt,
        [
            {
                erlang:list_to_atom(
                    erlang:binary_to_list(Name)
                ),
                to_type(V, Type)
            }
            | Ret
        ]
    );
    
name_columns([], [], Ret) ->
    {Ret};
name_columns([], V, Ret) ->
    %?D("unexpected values: ~p~n", [V]),
    {Ret};
name_columns(C, [], Ret) ->
    %?D("unexpected columns: ~p~n", [C]),
    {Ret}.

make_proplist(Columns, [V|T], Ret) ->
    make_proplist(Columns, T, [name_columns(Columns, tuple_to_list(V), [])|Ret]);
make_proplist(_C, [], Ret) ->
    Ret.

pgret(returning, {ok, Id}) ->
    
    {ok, Id};

pgret(returning, {ok, 1, _, [{Value}]}) ->

    {ok, Value};

pgret(_, Value) ->

    pgret(Value).

pgret({return, Value}) ->

    {ok, Value};

%%%
%%% select sq & eq
%%%
pgret({ok, Columns, Vals}) ->
    
    {ok, make_proplist(Columns, Vals, [])};


pgret([{ok, _columns, _vals}|_rest] = List) ->

    pgret_mult(List, []);
    
%%%
%%% update sq & eq
%%%
pgret({ok, Count}) ->
    {ok, Count};

%%%
%%% insert sq & eq
%%%
pgret({ok, 1, Columns, Vals}) ->
%     [{[{_,Res}]}] = make_proplist(Columns, Vals, []),
%     {ok, Res};
    {ok, make_proplist(Columns, Vals, [])};

%%%
%%% insert sq & eq
%%%
pgret({ok, _Count, Columns, Vals}) ->
    {ok, make_proplist(Columns, Vals, [])};

%%% 
%%% @doc    Ошибка сиквела - неожиданный возврат в функции
%%%         дает ошибку ожидаемого возврата.
%%%
pgret({pgcp_error, E}) ->

    pgreterr(E);

pgret({error, E}) ->

    pgreterr(E);

pgret(V) ->

    {retVal, V}.

pgret_mult([], Acc) ->
    Acc;
pgret_mult([{ok, Columns, Vals}|Rest], Acc) ->
    Res = make_proplist(Columns, Vals, []),
    pgret_mult(Rest, [{ok, Res}|Acc]).


pgreterr({error, E}) ->
    pgreterr(E);
pgreterr({badmatch, E}) ->
    pgreterr(E);
pgreterr(#error{code=Error_code_bin, message=Msg}) ->
    case Error_code_bin of
        <<"23502">> ->
            try
                {ok, Re} = re:compile("\"(.+)\""),
                {match, [_, C | _]} = re:run(Msg, Re, [{capture, all, list}]),
                {error, {not_null, erlang:list_to_binary(C)}}
            catch
                E:R ->
                    io:format("pgret ERROR(~p): ~p ~p - ~p~n", [?LINE, Msg, E, R]),
                    {error, {unknown, Msg}}
            end;
        <<"23503">> ->
            try
                {ok, Re} = re:compile("\"(.*?)*?_([^_].+)_fkey\""),
                {match, [_, _, C | _]} = re:run(Msg, Re, [{capture, all, list}]),
                {error, {not_exists, erlang:list_to_binary(C)}}
            catch
                E:R ->
                    io:format("pgret ERROR(~p): ~p ~p - ~p~n", [?LINE, Msg, E, R]),
                    {error, {unknown, Msg}}
            end;
        <<"23505">> ->
            try
                {ok, Reu} = re:compile("\"(.*?)*?_([^_].+)_key\""),
                {ok, Rep} = re:compile("\"(.*?)_pkey\""),
                case
                    {   re:run(Msg, Reu, [{capture, all, list}]),
                        re:run(Msg, Rep, [{capture, all, list}])
                    }
                of
                    {{match, [_, _, C | _]},_} ->
                        {error, {not_unique, erlang:list_to_binary(C)}};
                    {nomatch,{match,[_,C]}} ->
                        {error, {not_unique, erlang:list_to_binary(C)}}
                end
            catch
                E:R ->
                    io:format("pgret ERROR(~p): ~p ~p - ~p~n", [?LINE, Msg, E, R]),
                    {error, {unknown, Msg}}
            end;
        Code ->
            io:format("Code ~p ~n", [Code]),
            {error, {unknown, Msg}}
    end;
pgreterr(E) ->
    {error, {unexpected, E}}.


%%
%% 
%%
with_connection(Function) ->
    with_connection(emp, Function).

with_connection(Pool, Function) ->
    psqlcp:with_connection(Pool, Function).
    
%%
%%
%%
with_transaction(Function) ->
    with_transaction(emp, Function).

with_transaction(Pool, Function) ->
    psqlcp:with_transaction(Pool, Function).

%%%
%%% @doc    Выполняет преобразование ответа базы в соответсвии
%%%         со здравым смыслом. Если запрашиваем 1 объект,
%%%         то и разультат должны быть один. Вот это лочигнее
%%%         {ok, [{"name", "Name"}]} =
%%%             empdb_dao:one(
%%%                 empdb_dao:simple("select name from table where id = 1")
%%%             ).
%%%         чем
%%%             {ok, [[{"name", "Name"}]]} =
%%%                 empdb_dao:simple("select name from table where id = 1").
%%%
one({ok, []})         -> {ok, undefined};
one({ok, [Some]})     -> {ok, Some};
one({ok, Several})    -> {ok, Several};
one(Error)            -> Error.

%%% 
%%% @doc    Выполняет простой запрос и возвращает его результат в виде
%%%         {ok, Result} | {error, Error}
%%%         Может возвращать результат побочного действия.
%%%         Соединение создается само для этого запроса.
%%%
simple(Query)
    when erlang:is_list(Query)
        %orelse  erlang:is_binary(Query)
        orelse  erlang:is_function(Query)
        orelse  (
                    erlang:is_tuple(Query) andalso
                    2 =:= erlang:size(Query) andalso
                    erlang:is_function(erlang:element(1, Query)) andalso
                    erlang:is_function(erlang:element(2, Query))
                ) ->
    empdb_dao:with_connection(fun(Con)->eqret(Con, Query)end).

%%%
%%% @doc    Выполняет простой запрос и возвращает его результат в виде
%%%         {ok, Result} | {error, Error} | [{ok, Result}] | [{error, Error}]
%%%         Возможен множественный запрос без параментров.
%%%         Запросы должны отделяться через `;'.
%%%         Может возвращать результат побочного действия.
%%%         Соединение создается само для этого запроса.
%%%
simple_bulk(Query)
    when erlang:is_list(Query)
        %orelse  erlang:is_binary(Query)
        orelse  erlang:is_function(Query)
        orelse  (
                    erlang:is_tuple(Query) andalso
                    2 =:= erlang:size(Query) andalso
                    erlang:is_function(erlang:element(1, Query)) andalso
                    erlang:is_function(erlang:element(2, Query))
                ) ->
    empdb_dao:with_connection(fun(Con)->sqret(Con,Query)end).


%%% 
%%% @doc    Выполняет простой запрос и возвращает его результат в виде
%%%         {ok, Result} | {error, Error}
%%%         Может возвращать результат побочного действия.
%%%         Соединение создается само для этого запроса.
%%%
simple(Query, Params) ->
    empdb_dao:with_connection(fun(Con)->eqret(Con, Query, Params)end).

%%%
%%% @doc    Выполняет простой запрос и возвращает его результат в виде
%%%         {ok, Result} | {error, Error} 
%%%         Может возвращать результат побочного действия.
%%%         Обертка для функции ?MODULE:equery/2 -> ?MODULE:pgret/1
%%%         Кроме запроса необходимо еще указать соединение.
%%%
eqret(Con, Query)->
    io:format("1 eqret(Con, Query)->~n"),
    S = pgret(equery(Con, Query)),
    io:format("2 eqret(Con, Query)->~n"),
    S.

%%%
%%% @doc    Выполняет простой запрос и возвращает его результат в виде
%%%         {ok, Result} | {error, Error} | [{ok, Result}] | [{error, Error}]
%%%         Возможен множественный запрос без параментров.
%%%         Запросы должны отделяться через `;'.
%%%         Может возвращать результат побочного действия.
%%%         Обертка для функции ?MODULE:squery/2 -> ?MODULE:pgret/1
%%%         Кроме запроса необходимо еще указать соединение.
%%%
sqret(Con, Query)->
    pgret(squery(Con, Query)).

%%%
%%% @doc    Выполняет простой запрос и возвращает его результат в виде
%%%         {ok, Result} | {error, Error}
%%%         Может возвращать результат побочного действия.
%%%         Обертка для функции ?MODULE:еquery/3 -> ?MODULE:pgret/1
%%%         Кроме запроса необходимо еще указать соединение.
%%%
eqret(Con, Query, Params)->
    io:format("1 eqret(Con, Query, Params)->~n"),
    X = pgret(equery(Con, Query, Params)),
    io:format("2 eqret(Con, Query, Params)->~n"),
    X.

% ---------------------------------------------------------------------------
% %%% @depricated
% %%% @doc  Выполняет простой запрос
% %%%       и возвращает результат побочного действия
% %%%
% simple_ret(Query, Params) ->
%     Pre_result = empdb_dao:with_connection(
%             fun(Con) -> equery(Con, Query, Params)
%         end),
%     case empdb_dao:pgret(Pre_result) of
%         ok ->
%             Pre_result;
%         Error ->
%             {error, Error}
%     end.
% ---------------------------------------------------------------------------

%%% 
%%% @doc    Обертка для функции ?MODULE:equery/3 c функцией запроса
%%%         Выполныет запрос заданный функцией.
%%%         После самого запроса выполняется Callback
%%%         Callback выполняется отдельным потоком,
%%%             но при этом в случае его падения (в случае ошибки),<<"insert into friend (pers_id, friend_id) values ($pers_id, $friend_id) returning id; ">>

%%%                 текущий процесс тоже упадет
%%%
equery(Con, {Qfunction, Callback}, Params)
        when erlang:is_function(Qfunction)
            andalso erlang:is_function(Callback) ->
    Result = equery(Con, Qfunction, Params),
    spawn_link(
        ?MODULE,
        fcallback,
        [
            Con,
            Callback,
            {
                Qfunction,
                Params,
                Result
            }
        ]
    ),
    Result;

%%% 
%%% @doc    Обертка для функции ?MODULE:equery/3
%%%         Выполныет запрос заданный функцией.
%%%         Функция обязана возвращать строку.
%%%
equery(Con, Qfunction, Params) when erlang:is_function(Qfunction) ->
    equery(Con, fquery(Con, Qfunction, Params), Params);

%%% 
%%% @doc    Обертка для стандвартной функции psqlcp
%%%         Выполныет заданный запрос
%%%         Если параметры функции являются proplist
%%%         то происходит их распарсивание и подстановка согласно
%%%         с буквенными именами в теле запроса
%%%         Сделано это для того, чтобы в случае, если мы будем менять,
%%%         наши запросы, не приходилось высчитывать порядок следования.
%%%         Последнее очень не удобно для запросов с более чем 5 параметров.
%%%
equery(Con, Query, Params) when erlang:is_list(Query);erlang:is_binary(Query) ->
    case is_proplist(Params) of
        true ->
            io:format("FQ = ~p~n", [empdb_convert:to_binary(Query)]),
            {NewQuery, Values} = equery_pl(Query, Params),
            io:format("PQ = ~p~n", [empdb_convert:to_binary(NewQuery)]),
            io:format("PP = ~p~n", [Params]),
            io:format("PV = ~p~n", [Values]),
            psqlcp:equery(Con, NewQuery, Values);
        _ ->
            io:format("PQ = ~p~n", [empdb_convert:to_binary(Query)]),
            io:format("PP = ~p~n", [Params]),
            psqlcp:equery(Con, Query, Params)
    end.

%%% 
%%% @doc    Обертка для функции ?MODULE:equery/2
%%%         Выполныет запрос заданный функцией.
%%%         Функция обязана возвращать строку.
%%%
equery(Con, {Qfunction, Callback})
        when erlang:is_function(Qfunction)
            andalso erlang:is_function(Callback) ->
    Result = equery(Con, Qfunction),
    spawn_link(
        ?MODULE,
        fcallback,
        [
            Con,
            Callback,
            {
                Qfunction,
                Result
            }
        ]
    ),
    Result;

equery(Con, Function) when erlang:is_function(Function) ->
    equery(Con, fquery(Con, Function, []));

equery(Con, Query) when erlang:is_list(Query); erlang:is_binary(Query) ->
    io:format("equery(Con, Query) when erlang:is_list(Query) "),
    psqlcp:equery(Con, Query).


squery(Con, {Qfunction, Callback})
        when erlang:is_function(Qfunction)
            andalso erlang:is_function(Callback) ->
    Result = squery(Con, Qfunction),
    spawn_link(
        ?MODULE,
        fcallback,
        [
            Con,
            Callback,
            {
                Qfunction,
                Result
            }
        ]
    ),
    Result;

squery(Con, Function) when erlang:is_function(Function) ->
    squery(Con, fquery(Con, Function, []));

squery(Con, Query) when erlang:is_list(Query) ->
    psqlcp:squery(Con, Query).


%%% 
%%% @doc    Функция преобразования запроса с буквенными именами к числовым.
%%%         Запрос: empdb_dao:equery_pl(
%%%                     "select id from customer where id = $id and uid = $uid",
%%%                     [{"id", 10}, {"uid", 15}]
%%%                 ).
%%%         Вернет: "select id from customer where id = $1 and uid = $2"
%%%
equery_pl(Query, Kvpl) ->
    Rr = empdb_convert:to_binary(Query),
    {Newuery, _, Resvalues} =
        lists:foldl(fun
            (<<"$", Item/binary>> , {Prev, Cnt, Values}) ->
                case lists:keyfind(erlang:binary_to_atom(Item, utf8), 1, Kvpl) of
                    {Key, Value} ->
                        {
                            [Prev,equery_variable([{cnt, Cnt}])],
                            Cnt+1,
                            [Value|Values]
                        };
                    false ->
                        {[Prev, Item], Cnt, Values}
                end;
            (Item, {Prev, Cnt, Values}) ->
                {[Prev, Item], Cnt, Values}
        end, {[], 1, []}, re:split([Query, <<" ">>],"([$].*?)([\\s,;%\\(\\)])")),
    {empdb_convert:to_binary(Newuery), lists:reverse(Resvalues)}.

equery_variable(Current)->
    equery_variable(postgres, Current).

equery_variable(postgres, Current)->
    Cnt = proplists:get_value(cnt, Current),
    [<<"$">>, empdb_convert:to_list(Cnt)];

equery_variable(mysql, Current)->
    <<"?">>;

equery_variable(Valriant, Current)->
    <<" ">>.


%%%
%%% @doc
%%%     Функция преобразования запроса, основная рабочая часть.
%%%     Параметры разбиваем на {k, v}
%%%         Преобразованное имя ключа $k заменится
%%%             на его порядковый номер в списке.
%%%         Значение (v) отправится в список значений,
%%%             который далее будет использован для стандартного запроса
%%%             тут важно соблюсти порядок следования значений
%%%                 (Values ++[Value]) a не [Value|Values] !!!
%%%     Чтобы не перекомпилевать одинаковые ключи
%%%         результаты подстановки сохраняются
%%%             с использованием мемоизациию.
%%%
%%% TODO:
%%%     Возможно, надо переделать, так, чтобы оно работало и с mysql.
%%%     Изменять не следование переменных в запросе,
%%%     а следование параметров в списке параметров.
%%%
% 
% equery_pl(Query, [], _, Values) ->
%     {Query, Values};
% 
% equery_pl(Query, [{Name, Value}|Rest], Cnt, Values) ->
%     %%%
%     %%% Мемоизациия для вычисления 1 раз.
%     %%%
%     Newquery = equery_construct(Query, Name, Cnt),
%     case Newquery == Query of
%         true ->
%             equery_pl(Query, Rest, Cnt, Values);
%         _ ->
%             equery_pl(Newquery, Rest, Cnt + 1, lists:append(Values, [Value]))
%     end;
% 
% equery_pl(Query, List, _, _) when erlang:is_list(List) ->
%     {Query, List}.
% 
% %%%
% %%% @doc
% %%%     Функция преобразования запроса,
% %%%     Подстановка.
% %%%
% equery_construct(Query, Name, Cnt) ->
%     %%% 
%     %%% Мемоизациия для вычисления 1 раз.
%     %%% Многие паттерны встречаются достаточно часто,
%     %%%     более чем в одном запросе
%     %%% Например id, name ...
%     %%%
%     re:replace(
%         Query,
%         equery_construct_re(Name),
%         ?SVAR ++ empdb_convert:to_list(Cnt),
%         [global, {return,list}]
%     ).
% 
% %%%
% %%% @doc
% %%%     Функция преобразования запроса,
% %%%     Формирование паттерна для подстановки
% %%%
% equery_construct_re(Name)->
%     {ok, Cre} =
%         re:compile(
%             "[" ++
%                 ?SVAR ++
%             "]" ++
%             empdb_convert:to_list(Name)
%         ),
%     Cre.

%%% 
%%% @doc
%%%     Конструирует запрос, заданный функцией.
%%%     Кеширует резльтат выполнения функции.
%%%     !ВАЖНО: что функция вызывается до выполнения самого запроса
%%%
fquery(Con, Qfunction, Param)
        when erlang:is_function(Qfunction, 2) ->
    empdb_memo:lsave(Qfunction, [Con, Param]);

fquery(Con, Qfunction, _)
        when erlang:is_function(Qfunction, 1) ->
    empdb_memo:lsave(Qfunction, [Con]);

fquery(_, Qfunction, _)
        when erlang:is_function(Qfunction, 0) ->
    empdb_memo:lsave(Qfunction, []).


%%% @doc
%%%     Конструирует запрос, заданный функцией.
%%%     Кеширует резльтат выполнения функции.
%%%     !ВАЖНО: что функция вызывается после выполнения самого запроса
%%%
fcallback(Con, Callback, {Qfunction, Params, Result})
        when erlang:is_function(Callback, 4) ->
    empdb_memo:lsave(Callback, [Con, Qfunction, Params, Result]);

fcallback(Con, Callback, {Qfunction, Params, Result})
        when erlang:is_function(Callback, 2) ->
    empdb_memo:lsave(Callback, [Con, {Qfunction, Params, Result}]);

fcallback(Con, Callback, _)
        when erlang:is_function(Callback, 1) ->
    empdb_memo:lsave(Callback, [Con]);

fcallback(_, Callback, _)
        when erlang:is_function(Callback, 0) ->
    empdb_memo:lsave(Callback, []).

%%% -------------------------------------------------------------------------
%%% Функциии тестирования
%%% -------------------------------------------------------------------------

is_proplist([]) ->
    true;
is_proplist([{K,_}|R]) when is_atom(K) ->
    %%% {key, _}
    is_proplist(R);
is_proplist([{K,_}|R]) when is_list(K) ->
    %%% {"key", _}
    is_proplist(R);

is_proplist(_) ->
    false.

test()->

    ok.


test(speed)->
    ok.
